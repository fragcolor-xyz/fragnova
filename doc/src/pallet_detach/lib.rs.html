<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `pallets/detach/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/source-script-5cf2e01a42cc9858.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../pallet_detach/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
<a href="#555" id="555">555</a>
<a href="#556" id="556">556</a>
<a href="#557" id="557">557</a>
<a href="#558" id="558">558</a>
<a href="#559" id="559">559</a>
<a href="#560" id="560">560</a>
<a href="#561" id="561">561</a>
<a href="#562" id="562">562</a>
<a href="#563" id="563">563</a>
<a href="#564" id="564">564</a>
<a href="#565" id="565">565</a>
<a href="#566" id="566">566</a>
<a href="#567" id="567">567</a>
<a href="#568" id="568">568</a>
<a href="#569" id="569">569</a>
<a href="#570" id="570">570</a>
<a href="#571" id="571">571</a>
<a href="#572" id="572">572</a>
<a href="#573" id="573">573</a>
<a href="#574" id="574">574</a>
<a href="#575" id="575">575</a>
<a href="#576" id="576">576</a>
<a href="#577" id="577">577</a>
<a href="#578" id="578">578</a>
<a href="#579" id="579">579</a>
<a href="#580" id="580">580</a>
<a href="#581" id="581">581</a>
<a href="#582" id="582">582</a>
<a href="#583" id="583">583</a>
<a href="#584" id="584">584</a>
<a href="#585" id="585">585</a>
<a href="#586" id="586">586</a>
<a href="#587" id="587">587</a>
<a href="#588" id="588">588</a>
<a href="#589" id="589">589</a>
<a href="#590" id="590">590</a>
<a href="#591" id="591">591</a>
<a href="#592" id="592">592</a>
<a href="#593" id="593">593</a>
<a href="#594" id="594">594</a>
<a href="#595" id="595">595</a>
<a href="#596" id="596">596</a>
<a href="#597" id="597">597</a>
<a href="#598" id="598">598</a>
<a href="#599" id="599">599</a>
<a href="#600" id="600">600</a>
<a href="#601" id="601">601</a>
<a href="#602" id="602">602</a>
<a href="#603" id="603">603</a>
<a href="#604" id="604">604</a>
<a href="#605" id="605">605</a>
<a href="#606" id="606">606</a>
<a href="#607" id="607">607</a>
<a href="#608" id="608">608</a>
<a href="#609" id="609">609</a>
<a href="#610" id="610">610</a>
<a href="#611" id="611">611</a>
<a href="#612" id="612">612</a>
<a href="#613" id="613">613</a>
<a href="#614" id="614">614</a>
<a href="#615" id="615">615</a>
<a href="#616" id="616">616</a>
<a href="#617" id="617">617</a>
<a href="#618" id="618">618</a>
<a href="#619" id="619">619</a>
<a href="#620" id="620">620</a>
<a href="#621" id="621">621</a>
<a href="#622" id="622">622</a>
<a href="#623" id="623">623</a>
<a href="#624" id="624">624</a>
<a href="#625" id="625">625</a>
<a href="#626" id="626">626</a>
<a href="#627" id="627">627</a>
<a href="#628" id="628">628</a>
<a href="#629" id="629">629</a>
<a href="#630" id="630">630</a>
<a href="#631" id="631">631</a>
<a href="#632" id="632">632</a>
<a href="#633" id="633">633</a>
<a href="#634" id="634">634</a>
<a href="#635" id="635">635</a>
<a href="#636" id="636">636</a>
<a href="#637" id="637">637</a>
<a href="#638" id="638">638</a>
<a href="#639" id="639">639</a>
<a href="#640" id="640">640</a>
<a href="#641" id="641">641</a>
<a href="#642" id="642">642</a>
<a href="#643" id="643">643</a>
<a href="#644" id="644">644</a>
<a href="#645" id="645">645</a>
<a href="#646" id="646">646</a>
<a href="#647" id="647">647</a>
<a href="#648" id="648">648</a>
<a href="#649" id="649">649</a>
<a href="#650" id="650">650</a>
<a href="#651" id="651">651</a>
<a href="#652" id="652">652</a>
<a href="#653" id="653">653</a>
<a href="#654" id="654">654</a>
<a href="#655" id="655">655</a>
<a href="#656" id="656">656</a>
<a href="#657" id="657">657</a>
<a href="#658" id="658">658</a>
<a href="#659" id="659">659</a>
<a href="#660" id="660">660</a>
<a href="#661" id="661">661</a>
<a href="#662" id="662">662</a>
<a href="#663" id="663">663</a>
<a href="#664" id="664">664</a>
<a href="#665" id="665">665</a>
<a href="#666" id="666">666</a>
<a href="#667" id="667">667</a>
<a href="#668" id="668">668</a>
<a href="#669" id="669">669</a>
<a href="#670" id="670">670</a>
<a href="#671" id="671">671</a>
<a href="#672" id="672">672</a>
<a href="#673" id="673">673</a>
<a href="#674" id="674">674</a>
<a href="#675" id="675">675</a>
<a href="#676" id="676">676</a>
<a href="#677" id="677">677</a>
<a href="#678" id="678">678</a>
<a href="#679" id="679">679</a>
<a href="#680" id="680">680</a>
<a href="#681" id="681">681</a>
<a href="#682" id="682">682</a>
<a href="#683" id="683">683</a>
<a href="#684" id="684">684</a>
<a href="#685" id="685">685</a>
<a href="#686" id="686">686</a>
<a href="#687" id="687">687</a>
<a href="#688" id="688">688</a>
<a href="#689" id="689">689</a>
<a href="#690" id="690">690</a>
<a href="#691" id="691">691</a>
<a href="#692" id="692">692</a>
<a href="#693" id="693">693</a>
<a href="#694" id="694">694</a>
<a href="#695" id="695">695</a>
<a href="#696" id="696">696</a>
<a href="#697" id="697">697</a>
<a href="#698" id="698">698</a>
<a href="#699" id="699">699</a>
<a href="#700" id="700">700</a>
<a href="#701" id="701">701</a>
<a href="#702" id="702">702</a>
<a href="#703" id="703">703</a>
<a href="#704" id="704">704</a>
<a href="#705" id="705">705</a>
<a href="#706" id="706">706</a>
<a href="#707" id="707">707</a>
<a href="#708" id="708">708</a>
<a href="#709" id="709">709</a>
<a href="#710" id="710">710</a>
<a href="#711" id="711">711</a>
<a href="#712" id="712">712</a>
<a href="#713" id="713">713</a>
<a href="#714" id="714">714</a>
<a href="#715" id="715">715</a>
<a href="#716" id="716">716</a>
<a href="#717" id="717">717</a>
<a href="#718" id="718">718</a>
<a href="#719" id="719">719</a>
<a href="#720" id="720">720</a>
<a href="#721" id="721">721</a>
<a href="#722" id="722">722</a>
<a href="#723" id="723">723</a>
<a href="#724" id="724">724</a>
<a href="#725" id="725">725</a>
<a href="#726" id="726">726</a>
<a href="#727" id="727">727</a>
<a href="#728" id="728">728</a>
<a href="#729" id="729">729</a>
<a href="#730" id="730">730</a>
<a href="#731" id="731">731</a>
<a href="#732" id="732">732</a>
<a href="#733" id="733">733</a>
<a href="#734" id="734">734</a>
<a href="#735" id="735">735</a>
<a href="#736" id="736">736</a>
<a href="#737" id="737">737</a>
<a href="#738" id="738">738</a>
<a href="#739" id="739">739</a>
<a href="#740" id="740">740</a>
<a href="#741" id="741">741</a>
<a href="#742" id="742">742</a>
<a href="#743" id="743">743</a>
<a href="#744" id="744">744</a>
<a href="#745" id="745">745</a>
<a href="#746" id="746">746</a>
<a href="#747" id="747">747</a>
<a href="#748" id="748">748</a>
<a href="#749" id="749">749</a>
<a href="#750" id="750">750</a>
<a href="#751" id="751">751</a>
<a href="#752" id="752">752</a>
<a href="#753" id="753">753</a>
<a href="#754" id="754">754</a>
<a href="#755" id="755">755</a>
<a href="#756" id="756">756</a>
<a href="#757" id="757">757</a>
<a href="#758" id="758">758</a>
<a href="#759" id="759">759</a>
<a href="#760" id="760">760</a>
<a href="#761" id="761">761</a>
<a href="#762" id="762">762</a>
<a href="#763" id="763">763</a>
<a href="#764" id="764">764</a>
<a href="#765" id="765">765</a>
<a href="#766" id="766">766</a>
<a href="#767" id="767">767</a>
<a href="#768" id="768">768</a>
<a href="#769" id="769">769</a>
<a href="#770" id="770">770</a>
<a href="#771" id="771">771</a>
<a href="#772" id="772">772</a>
<a href="#773" id="773">773</a>
<a href="#774" id="774">774</a>
<a href="#775" id="775">775</a>
<a href="#776" id="776">776</a>
<a href="#777" id="777">777</a>
<a href="#778" id="778">778</a>
<a href="#779" id="779">779</a>
<a href="#780" id="780">780</a>
<a href="#781" id="781">781</a>
<a href="#782" id="782">782</a>
<a href="#783" id="783">783</a>
<a href="#784" id="784">784</a>
<a href="#785" id="785">785</a>
<a href="#786" id="786">786</a>
<a href="#787" id="787">787</a>
<a href="#788" id="788">788</a>
<a href="#789" id="789">789</a>
<a href="#790" id="790">790</a>
<a href="#791" id="791">791</a>
<a href="#792" id="792">792</a>
<a href="#793" id="793">793</a>
<a href="#794" id="794">794</a>
<a href="#795" id="795">795</a>
<a href="#796" id="796">796</a>
<a href="#797" id="797">797</a>
<a href="#798" id="798">798</a>
<a href="#799" id="799">799</a>
<a href="#800" id="800">800</a>
<a href="#801" id="801">801</a>
<a href="#802" id="802">802</a>
<a href="#803" id="803">803</a>
<a href="#804" id="804">804</a>
<a href="#805" id="805">805</a>
<a href="#806" id="806">806</a>
<a href="#807" id="807">807</a>
<a href="#808" id="808">808</a>
<a href="#809" id="809">809</a>
<a href="#810" id="810">810</a>
<a href="#811" id="811">811</a>
<a href="#812" id="812">812</a>
<a href="#813" id="813">813</a>
<a href="#814" id="814">814</a>
<a href="#815" id="815">815</a>
<a href="#816" id="816">816</a>
<a href="#817" id="817">817</a>
<a href="#818" id="818">818</a>
<a href="#819" id="819">819</a>
<a href="#820" id="820">820</a>
<a href="#821" id="821">821</a>
<a href="#822" id="822">822</a>
<a href="#823" id="823">823</a>
<a href="#824" id="824">824</a>
<a href="#825" id="825">825</a>
<a href="#826" id="826">826</a>
<a href="#827" id="827">827</a>
<a href="#828" id="828">828</a>
<a href="#829" id="829">829</a>
<a href="#830" id="830">830</a>
<a href="#831" id="831">831</a>
<a href="#832" id="832">832</a>
<a href="#833" id="833">833</a>
<a href="#834" id="834">834</a>
<a href="#835" id="835">835</a>
<a href="#836" id="836">836</a>
<a href="#837" id="837">837</a>
<a href="#838" id="838">838</a>
<a href="#839" id="839">839</a>
<a href="#840" id="840">840</a>
<a href="#841" id="841">841</a>
<a href="#842" id="842">842</a>
<a href="#843" id="843">843</a>
<a href="#844" id="844">844</a>
<a href="#845" id="845">845</a>
<a href="#846" id="846">846</a>
<a href="#847" id="847">847</a>
<a href="#848" id="848">848</a>
<a href="#849" id="849">849</a>
<a href="#850" id="850">850</a>
<a href="#851" id="851">851</a>
<a href="#852" id="852">852</a>
<a href="#853" id="853">853</a>
<a href="#854" id="854">854</a>
<a href="#855" id="855">855</a>
<a href="#856" id="856">856</a>
<a href="#857" id="857">857</a>
<a href="#858" id="858">858</a>
<a href="#859" id="859">859</a>
<a href="#860" id="860">860</a>
<a href="#861" id="861">861</a>
<a href="#862" id="862">862</a>
<a href="#863" id="863">863</a>
<a href="#864" id="864">864</a>
<a href="#865" id="865">865</a>
<a href="#866" id="866">866</a>
<a href="#867" id="867">867</a>
<a href="#868" id="868">868</a>
<a href="#869" id="869">869</a>
<a href="#870" id="870">870</a>
<a href="#871" id="871">871</a>
<a href="#872" id="872">872</a>
<a href="#873" id="873">873</a>
<a href="#874" id="874">874</a>
<a href="#875" id="875">875</a>
<a href="#876" id="876">876</a>
<a href="#877" id="877">877</a>
<a href="#878" id="878">878</a>
</pre><pre class="rust"><code><span class="doccomment">//! This pallet `detach` performs logic related to Detaching a Proto-Fragment from the Fragnova
//! Blockchain to an External Blockchain

</span><span class="comment">// Ensure we&#39;re `no_std` when compiling for Wasm.
</span><span class="attr">#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]

#[cfg(test)]
</span><span class="kw">mod </span>dummy_data;

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>mock;

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>tests;

<span class="attr">#[cfg(feature = <span class="string">&quot;runtime-benchmarks&quot;</span>)]
</span><span class="kw">mod </span>benchmarking;

<span class="kw">mod </span>merkle_tree;

<span class="attr">#[allow(missing_docs)]
</span><span class="kw">mod </span>weights;

<span class="kw">use </span>sp_core::{crypto::KeyTypeId, ecdsa, ed25519, U256};

<span class="doccomment">/// Defines application identifier for crypto keys of this module.
///
/// Every module that deals with signatures needs to declare its unique identifier for
/// its crypto keys.
/// When offchain worker is signing transactions it&#39;s going to request keys of type
/// `KeyTypeId` from the keystore and use the ones it finds to sign the transaction.
/// The keys can be inserted manually via RPC (see `author_insertKey`).
</span><span class="kw">pub const </span>KEY_TYPE: KeyTypeId = KeyTypeId(<span class="kw-2">*</span><span class="string">b&quot;deta&quot;</span>);

<span class="doccomment">/// Based on the above `KeyTypeId` we need to generate a pallet-specific crypto type wrappers.
/// We can use from supported crypto kinds (`sr25519`, `ed25519` and `ecdsa`) and augment
/// the types with this pallet-specific identifier.
</span><span class="kw">pub mod </span>crypto {
	<span class="kw">use </span><span class="kw">super</span>::KEY_TYPE;
	<span class="kw">use </span>sp_core::ed25519::Signature <span class="kw">as </span>Ed25519Signature;
	<span class="kw">use </span>sp_runtime::{
		app_crypto::{app_crypto, ed25519},
		traits::Verify,
		MultiSignature, MultiSigner,
	};

	<span class="comment">// The app_crypto macro declares an account with an `ed25519` signature that is identified by
	// KEY_TYPE. Note that this doesn&#39;t create a new account.
	// The macro simply declares that a crypto account is available for this pallet.
	// You will need to initialize this account yourself.
	//
	// More info: https://docs.substrate.io/how-to-guides/v3/ocw/transactions/
	</span><span class="macro">app_crypto!</span>(ed25519, KEY_TYPE);

	<span class="doccomment">/// The identifier type for an offchain worker.
	</span><span class="kw">pub struct </span>DetachAuthId;

	<span class="comment">// implemented for runtime
	</span><span class="kw">impl </span>frame_system::offchain::AppCrypto&lt;MultiSigner, MultiSignature&gt; <span class="kw">for </span>DetachAuthId {
		<span class="kw">type </span>RuntimeAppPublic = Public;
		<span class="kw">type </span>GenericSignature = sp_core::ed25519::Signature;
		<span class="kw">type </span>GenericPublic = sp_core::ed25519::Public;
	}

	<span class="comment">// implemented for mock runtime in test
	</span><span class="kw">impl </span>frame_system::offchain::AppCrypto&lt;&lt;Ed25519Signature <span class="kw">as </span>Verify&gt;::Signer, Ed25519Signature&gt;
		<span class="kw">for </span>DetachAuthId
	{
		<span class="kw">type </span>RuntimeAppPublic = Public;
		<span class="kw">type </span>GenericSignature = sp_core::ed25519::Signature;
		<span class="kw">type </span>GenericPublic = sp_core::ed25519::Public;
	}
}

<span class="kw">pub use </span>pallet::<span class="kw-2">*</span>;
<span class="kw">pub use </span>weights::WeightInfo;

<span class="kw">use </span>codec::{Compact, Decode, Encode};
<span class="kw">use </span>sp_io::{crypto <span class="kw">as </span>Crypto, hashing::keccak_256, offchain_index};
<span class="kw">use </span>sp_runtime::{offchain::storage::StorageValueRef, traits::Hash, MultiSigner};
<span class="kw">use </span>sp_std::{collections::btree_set::BTreeSet, vec, vec::Vec};

<span class="kw">use </span>sp_fragnova::{Hash128, Hash256, fragments::InstanceUnit};

<span class="kw">use </span>frame_system::offchain::{
	AppCrypto, CreateSignedTransaction, SendUnsignedTransaction, SignedPayload, Signer,
	SigningTypes,
};

<span class="kw">use </span>merkle_tree::{merkle_root, Keccak256};

<span class="doccomment">/// Enum representing a &quot;detachable thing&quot; (i.e a Proto-Fragment or a Fragment Instance) that the User wants to detach from the Fragnova Blockchain
</span><span class="attr">#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
</span><span class="kw">pub enum </span>DetachHash {
	<span class="doccomment">/// A Proto-Fragment (identified by its Hash)
	</span>Proto(Hash256),
	<span class="doccomment">/// A Fragment Instance (identified as a tuple of its Fragment Definition Hash, its Edition ID and its Copy ID)
	</span>Instance(Hash128, Compact&lt;InstanceUnit&gt;, Compact&lt;InstanceUnit&gt;),
}

<span class="doccomment">/// Enum representing the different Collection Types
</span><span class="attr">#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
</span><span class="kw">pub enum </span>DetachCollectionType {
	<span class="doccomment">/// Every element in the collection represents a Proto-Fragment
	</span>Proto,
	<span class="doccomment">/// Every element in the collection represents a Fragment Instance
	</span>Instance,
}

<span class="doccomment">/// Enum representing a collection of &quot;detachable things&quot; that the User wants to detach from the Fragnova Blockchain
</span><span class="attr">#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
</span><span class="kw">pub enum </span>DetachCollection {
	<span class="doccomment">/// List of Proto-Fragments (identified by its Hash)
	</span>Protos(Vec&lt;Hash256&gt;),
	<span class="doccomment">/// List of Fragment Instances (identified as a tuple of its Fragment Definition Hash, its Edition ID and its Copy ID)
	</span>Instances(Vec&lt;(Hash128, Compact&lt;InstanceUnit&gt;, Compact&lt;InstanceUnit&gt;)&gt;),
}
<span class="kw">impl </span>DetachCollection {
	<span class="doccomment">/// Get the Collection type
	</span><span class="kw">fn </span>get_type(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; DetachCollectionType {
		<span class="kw">match </span><span class="self">self </span>{
			<span class="self">Self</span>::Protos(<span class="kw">_</span>) =&gt; DetachCollectionType::Proto,
			<span class="self">Self</span>::Instances(<span class="kw">_</span>) =&gt; DetachCollectionType::Instance,
		}
	}

	<span class="doccomment">/// Get the ABI-encoded list of hashes
	///
	/// For Proto-Fragments, the encoding is: `abi.encodePacked(protoHash)`, where `protoHash` is of type `bytes32`
	/// For Fragment Instances, the encoding is: `abi.encodePacked(definitionHash, editionId, copyId)`, where:
	/// 	- `definitionHash` is of type `bytes16`
	/// 	- `editionId` is of type `uint64`
	/// 	- `copyId` is of type `uint64`
	</span><span class="kw">fn </span>get_abi_encoded_hashes(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
		<span class="kw">match </span><span class="self">self </span>{
			<span class="self">Self</span>::Protos(proto_hashes) =&gt;
				proto_hashes.iter().map(|proto_hash| proto_hash.to_vec()).collect(),
			<span class="self">Self</span>::Instances(instances) =&gt; instances
				.iter()
				.map(|(definition_hash, Compact(edition_id), Compact(copy_id))| {
					[
						<span class="kw-2">&amp;</span>definition_hash[..],
						<span class="kw-2">&amp;</span>edition_id.to_be_bytes()[..],
						<span class="kw-2">&amp;</span>copy_id.to_be_bytes()[..],
					]
					.concat()
				})
				.collect(),
		}
	}
}

<span class="doccomment">/// **Possible Blockchains** into which a **Proto-Fragment** can be **detached**
</span><span class="attr">#[derive(Encode, Decode, Copy, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
</span><span class="kw">pub enum </span>SupportedChains {
	<span class="doccomment">/// Ethereum Mainnet Chain
	</span>EthereumMainnet,
	<span class="doccomment">/// Ethereum Rinkeby Chain
	</span>EthereumRinkeby,
	<span class="doccomment">/// Ethereum Goerli Chain
	</span>EthereumGoerli,
}

<span class="doccomment">/// **Struct** that represents a **request to detach a collection of &quot;detachable thing&quot;s (see enum `DetachHashes` to see what type of collections can be detached)** from the Fragnova Blockchain
</span><span class="attr">#[derive(Encode, Decode, Clone, PartialEq, Debug, Eq, scale_info::TypeInfo)]
</span><span class="kw">pub struct </span>DetachRequest {
	<span class="doccomment">/// Collection of &quot;detachable thing&quot;s
	</span><span class="kw">pub </span>collection: DetachCollection,
	<span class="doccomment">/// **External Blockchain** in which the &quot;detachable thing&quot;s can be attached into, after the &quot;detachable thing&quot;s are detached
	</span><span class="kw">pub </span>target_chain: SupportedChains,
	<span class="doccomment">/// Public Account Address in the External Blockchain to transfer the ownership of the &quot;detachable thing&quot;s to
	</span><span class="kw">pub </span>target_account: Vec&lt;u8&gt;, <span class="comment">// an eth address or so
</span>}

<span class="doccomment">/// Payload represents information about a collection of &quot;detachable thing&quot;s (see enum `DetachHash` to see what type of collections can be detached) that will be detached
///
/// Note: This Payload that will be attached to the unsigned transaction `Call::internal_finalize_detach` which will be sent on-chain
</span><span class="attr">#[derive(Encode, Decode, Clone, scale_info::TypeInfo, Debug, PartialEq)]
</span><span class="kw">pub struct </span>DetachInternalData&lt;TPublic&gt; {
	<span class="doccomment">/// Public key that is expected to have a matching key in the keystore, which should be used to sign the payload
	///
	/// See this struct&#39;s implementation of `SignedPayload` for more information.
	</span><span class="kw">pub </span>public: TPublic,
	<span class="doccomment">/// Collection of &quot;detachable thing&quot;s
	</span><span class="kw">pub </span>collection: DetachCollection,
	<span class="doccomment">/// **Merkle Root** of a **Binary Merkle Tree created using `hashes`**
	</span><span class="kw">pub </span>merkle_root: Hash256,
	<span class="doccomment">/// **External Blockchain** in which the &quot;detachable thing&quot; can be attached into, after the &quot;detachable thing&quot; is detached
	</span><span class="kw">pub </span>target_chain: SupportedChains,
	<span class="doccomment">/// Public Account Address in the External Blockchain to transfer the ownership of the &quot;detachable thing&quot; to
	</span><span class="kw">pub </span>target_account: Vec&lt;u8&gt;, <span class="comment">// an eth address or so
	</span><span class="doccomment">/// Signature obtained by signing the detach request using a Fragnova-authorized account.
	/// After the &quot;detachable thing&quot; is detached, this signature can be presented to the External Blockchain to attach the &quot;detached thing&quot; to the External Blockchain.
	</span><span class="kw">pub </span>remote_signature: Vec&lt;u8&gt;,
	<span class="doccomment">/// Number of times the the `target_account` on the `target_chain` was specified as the new owner when a &quot;detachable thing&quot; (e.g a Proto-Fragment or a Fragment Instance) was detached.
	</span><span class="kw">pub </span>nonce: u64,
}

<span class="doccomment">/// Implementing the `SignedPayload` Trait allows `DetachInternalData` to be used as a signed payload that can be attached to unsigned transactions that are sent on-chain
/// See: https://paritytech.github.io/substrate/master/frame_system/offchain/trait.SignedPayload.html#
</span><span class="kw">impl</span>&lt;T: SigningTypes&gt; SignedPayload&lt;T&gt; <span class="kw">for </span>DetachInternalData&lt;T::Public&gt; {
	<span class="doccomment">/// Return a public key that is expected to have a matching key in the keystore, which should be used to sign the payload.
	///
	/// See: https://paritytech.github.io/substrate/master/frame_system/offchain/trait.SignedPayload.html#tymethod.public
	</span><span class="kw">fn </span>public(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; T::Public {
		<span class="self">self</span>.public.clone()
	}
}

<span class="doccomment">/// **Struct** that **contains information** about **a &quot;detached thing&quot;** (e.g **a detached Proto-Fragment** or a **detached Fragment Instance**) that was detached from the Fragnova Blockchain
</span><span class="attr">#[derive(Encode, Decode, Clone, scale_info::TypeInfo, Debug, PartialEq)]
</span><span class="kw">pub struct </span>ExportData {
	<span class="doccomment">/// **External Blockchain** the **&quot;detached thing&quot;** can be **attached to**
	</span>chain: SupportedChains,
	<span class="doccomment">/// Public Account Address (in the blockchain `chain`) to assign ownership of the &quot;detached thing&quot; to
	</span>owner: Vec&lt;u8&gt;,
	<span class="comment">// For now we don&#39;t allow to re-attach but in the future we will,
	// this nonce is in 1:1 relationship with the remote chain,
	// so that e.g. if we detach on ethereum the message cannot be repeated and needs to go 1:1 with fragnova
	</span><span class="doccomment">/// Detach-Nonce of the Public Account Address  `owner` (in the external blockchain `chain`) when the &quot;detached thing&quot; was detached
	</span>nonce: u64,
}

<span class="attr">#[frame_support::pallet]
</span><span class="kw">pub mod </span>pallet {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="kw">use </span>frame_support::{dispatch::DispatchResult, pallet_prelude::<span class="kw-2">*</span>};
	<span class="kw">use </span>frame_system::pallet_prelude::<span class="kw-2">*</span>;
	<span class="kw">use </span>sp_core::ed25519::Public;

	<span class="doccomment">/// Configure the pallet by specifying the parameters and types on which it depends.
	</span><span class="attr">#[pallet::config]
	</span><span class="kw">pub trait </span>Config:
		CreateSignedTransaction&lt;Call&lt;<span class="self">Self</span>&gt;&gt;
		+ pallet_randomness_collective_flip::Config
		+ frame_system::Config
	{
		<span class="doccomment">/// Because this pallet emits events, it depends on the runtime&#39;s definition of an event.
		</span><span class="kw">type </span>Event: From&lt;Event&lt;<span class="self">Self</span>&gt;&gt; + IsType&lt;&lt;<span class="self">Self </span><span class="kw">as </span>frame_system::Config&gt;::Event&gt;;
		<span class="doccomment">/// Weight functions needed for pallet_detach.
		</span><span class="kw">type </span>WeightInfo: WeightInfo;
		<span class="doccomment">/// The identifier type for an offchain worker.
		</span><span class="kw">type </span>AuthorityId: AppCrypto&lt;<span class="self">Self</span>::Public, <span class="self">Self</span>::Signature&gt;;
	}

	<span class="doccomment">/// The Genesis Configuration for the Pallet.
	</span><span class="attr">#[pallet::genesis_config]
	#[derive(Default)]
	</span><span class="kw">pub struct </span>GenesisConfig {
		<span class="doccomment">/// **List of ECDSA public keys of the Ethereum accounts** that are **authorized to detach a Proto-Fragment** onto **Fragnova&#39;s Ethereum Smart Contract**
		</span><span class="kw">pub </span>eth_authorities: Vec&lt;ecdsa::Public&gt;,
		<span class="doccomment">/// **List of Ed25519 Public Keys** that can both ***validate*** and ***send*** **unsigned transactions with signed payload**
		</span><span class="kw">pub </span>keys: Vec&lt;ed25519::Public&gt;,
	}

	<span class="attr">#[pallet::genesis_build]
	</span><span class="kw">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="kw">for </span>GenesisConfig {
		<span class="kw">fn </span>build(<span class="kw-2">&amp;</span><span class="self">self</span>) {
			Pallet::&lt;T&gt;::initialize_eth_authorities(<span class="kw-2">&amp;</span><span class="self">self</span>.eth_authorities);
			Pallet::&lt;T&gt;::initialize_keys(<span class="kw-2">&amp;</span><span class="self">self</span>.keys);
		}
	}

	<span class="attr">#[pallet::pallet]
	#[pallet::generate_store(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait </span>Store)]
	#[pallet::without_storage_info]
	</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);

	<span class="doccomment">/// **StorageValue** that equals the **list of detach requests**
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub type </span>DetachRequests&lt;T: Config&gt; = StorageValue&lt;<span class="kw">_</span>, Vec&lt;DetachRequest&gt;, ValueQuery&gt;;

	<span class="doccomment">/// **StorageDoubleMap** that maps an **account address on an external blockchain and the external blockchain**
	/// to a **nonce**.
	/// This nonce indicates the number of times the account address was specified as the new owner when a &quot;detachable thing&quot; (see enum `DetachHash` to see what type of things can be detached) was detached.
	///
	/// Note: In Fragnova&#39;s Smart Contract `CollectionFactory.sol`, the mapping state variable `nonces`&#39;s (`mapping(address =&gt; uint64) nonces`) nonce type is also `uint64`
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub type </span>DetachNonces&lt;T: Config&gt; =
		StorageDoubleMap&lt;<span class="kw">_</span>, Twox64Concat, Vec&lt;u8&gt;, Twox64Concat, SupportedChains, u64&gt;;

	<span class="doccomment">/// **StorageMap** that maps a **detached Proto-Fragment or a detached Fragment Instance** to an ***ExportData* enum (this enum contains information about the detachment)**
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub type </span>DetachedHashes&lt;T: Config&gt; = StorageMap&lt;<span class="kw">_</span>, Identity, DetachHash, ExportData&gt;;

	<span class="doccomment">/// **StorageValue** that equals the **exclusive set of Ethereum accounts (represented here as ECDSA public keys)** that are
	/// **authorized by Fragnova&#39;s Ethereum Smart Contract** to attach Proto-Fragment(s) into the aforementioned Smart Contract
	///
	/// Note: Only the Sudo User can edit `EthereumAuthorities`
	///
	/// Note 2: All the ECDSA public keys in `EthereumAuthorities` have been deterministically computed using the Ed25519 keys in the StorageValue `DetachKeys`
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub type </span>EthereumAuthorities&lt;T: Config&gt; = StorageValue&lt;<span class="kw">_</span>, BTreeSet&lt;ecdsa::Public&gt;, ValueQuery&gt;;

	<span class="comment">// These are the public keys representing the actual keys that can Sign messages
	// to present to external chains to detach onto
	</span><span class="doccomment">/// **StorageValue** that equals the **set of Ed25519 Public keys** that both ***validate*** and ***send*** **unsigned transactions with signed payload**
	///
	/// Note: Only the Sudo User can edit `DetachKeys`
	</span><span class="attr">#[pallet::storage]
	</span><span class="kw">pub type </span>DetachKeys&lt;T: Config&gt; = StorageValue&lt;<span class="kw">_</span>, BTreeSet&lt;ed25519::Public&gt;, ValueQuery&gt;;

	<span class="attr">#[allow(missing_docs)]
	#[pallet::event]
	#[pallet::generate_deposit(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>deposit_event)]
	</span><span class="kw">pub enum </span>Event&lt;T: Config&gt; {
		<span class="doccomment">/// A collection of &quot;detachable thing&quot;s was detached
		</span>CollectionDetached {
			merkle_root: Hash256,
			remote_signature: Vec&lt;u8&gt;,
			collection_type: DetachCollectionType,
			collection: DetachCollection,
		},
	}

	<span class="comment">// Errors inform users that something went wrong.
	</span><span class="attr">#[pallet::error]
	</span><span class="kw">pub enum </span>Error&lt;T&gt; {
		<span class="doccomment">/// Already detached
		</span>Detached,
		<span class="doccomment">/// No Validators are present
		</span>NoValidator,
		<span class="doccomment">/// Failed to sign message
		</span>SigningFailed,
		<span class="doccomment">/// Length of the Target Account in the Target Blockchain Does Not Adhere to the Target Blockchain&#39;s Specification
		</span>TargetAccountLengthIsIncorrect,
	}

	<span class="comment">// Dispatchable functions allows users to interact with the pallet and invoke state changes.
	// These functions materialize as &quot;extrinsics&quot;, which are often compared to transactions.
	// Dispatchable functions must be annotated with a weight and must return a DispatchResult.
	</span><span class="doccomment">/// Functions that are callable from outside the runtime.
	</span><span class="attr">#[pallet::call]
	</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
		<span class="doccomment">/// **Add** an **ECDSA public key** into **`EthereumAuthorities`**
		///
		/// Note: Only the Sudo User can edit `EthereumAuthorities`
		</span><span class="attr">#[pallet::weight(T::WeightInfo::add_eth_auth())]
		</span><span class="kw">pub fn </span>add_eth_auth(origin: OriginFor&lt;T&gt;, public: ecdsa::Public) -&gt; DispatchResult {
			ensure_root(origin)<span class="question-mark">?</span>;

			<span class="macro">log::debug!</span>(<span class="string">&quot;New eth auth: {:?}&quot;</span>, public);

			&lt;EthereumAuthorities&lt;T&gt;&gt;::mutate(|validators| {
				validators.insert(public);
			});

			<span class="prelude-val">Ok</span>(())
		}

		<span class="doccomment">/// **Remove** an **ECDSA public key** from **`EthereumAuthorities`**
		///
		/// Note: Only the Sudo User can edit `EthereumAuthorities`
		</span><span class="attr">#[pallet::weight(T::WeightInfo::del_eth_auth())]
		</span><span class="kw">pub fn </span>del_eth_auth(origin: OriginFor&lt;T&gt;, public: ecdsa::Public) -&gt; DispatchResult {
			ensure_root(origin)<span class="question-mark">?</span>;

			<span class="macro">log::debug!</span>(<span class="string">&quot;Removed eth auth: {:?}&quot;</span>, public);

			&lt;EthereumAuthorities&lt;T&gt;&gt;::mutate(|validators| {
				validators.remove(<span class="kw-2">&amp;</span>public);
			});

			<span class="prelude-val">Ok</span>(())
		}

		<span class="doccomment">/// **Add** an **Ed25519 public key** to `DetachKeys`
		///
		/// Note: Only the Sudo User can edit `EthereumAuthorities`
		</span><span class="attr">#[pallet::weight(T::WeightInfo::add_eth_auth())]
		</span><span class="kw">pub fn </span>add_key(origin: OriginFor&lt;T&gt;, public: ed25519::Public) -&gt; DispatchResult {
			ensure_root(origin)<span class="question-mark">?</span>;

			<span class="macro">log::debug!</span>(<span class="string">&quot;New key: {:?}&quot;</span>, public);

			&lt;DetachKeys&lt;T&gt;&gt;::mutate(|validators| {
				validators.insert(public);
			});

			<span class="prelude-val">Ok</span>(())
		}

		<span class="doccomment">/// **Remove** an **Ed25519 public key** from `DetachKeys`
		///
		/// Note: Only the Sudo User can edit `EthereumAuthorities`
		</span><span class="attr">#[pallet::weight(T::WeightInfo::del_eth_auth())]
		</span><span class="kw">pub fn </span>del_key(origin: OriginFor&lt;T&gt;, public: ed25519::Public) -&gt; DispatchResult {
			ensure_root(origin)<span class="question-mark">?</span>;

			<span class="macro">log::debug!</span>(<span class="string">&quot;Removed key: {:?}&quot;</span>, public);

			&lt;DetachKeys&lt;T&gt;&gt;::mutate(|validators| {
				validators.remove(<span class="kw-2">&amp;</span>public);
			});

			<span class="prelude-val">Ok</span>(())
		}

		<span class="doccomment">/// Detach a Proto-Fragment from Fragnova by emitting an event that includes a signature.
		</span><span class="attr">#[pallet::weight(<span class="number">25_000</span>)] </span><span class="comment">// TODO - weight
		</span><span class="kw">pub fn </span>internal_finalize_detach(
			origin: OriginFor&lt;T&gt;,
			data: DetachInternalData&lt;T::Public&gt;,
			_signature: T::Signature,
		) -&gt; DispatchResult {
			ensure_none(origin)<span class="question-mark">?</span>;

			<span class="comment">// Update nonce
			</span>&lt;DetachNonces&lt;T&gt;&gt;::insert(<span class="kw-2">&amp;</span>data.target_account, data.target_chain, data.nonce);

			<span class="kw">let </span>export_data = ExportData {
				chain: data.target_chain,
				owner: data.target_account,
				nonce: data.nonce,
			};

			<span class="comment">// add to `DetachedHashes` map
			</span><span class="kw">match </span><span class="kw-2">&amp;</span>data.collection {
				DetachCollection::Protos(proto_hashes) =&gt; {
					proto_hashes.iter().for_each(|proto_hash| {
						<span class="kw">let </span>detach_hash = DetachHash::Proto(<span class="kw-2">*</span>proto_hash);

						&lt;DetachedHashes&lt;T&gt;&gt;::insert(detach_hash.clone(), export_data.clone()); <span class="comment">// TODO Review - Should `DetachHash` implement the trait `Copy`?

						</span><span class="macro">log::debug!</span>(
							<span class="string">&quot;Detached hash: {:?} signature: {:?}&quot;</span>,
							detach_hash,
							data.remote_signature
						);
					});
				},
				DetachCollection::Instances(instances) =&gt; {
					instances.iter().for_each(|(definition_hash, edition_id, copy_id)| {
						<span class="kw">let </span>detach_hash =
							DetachHash::Instance(<span class="kw-2">*</span>definition_hash, <span class="kw-2">*</span>edition_id, <span class="kw-2">*</span>copy_id);

						&lt;DetachedHashes&lt;T&gt;&gt;::insert(detach_hash.clone(), export_data.clone()); <span class="comment">// TODO Review - Should `DetachHash` implement the trait `Copy`?

						</span><span class="macro">log::debug!</span>(
							<span class="string">&quot;Detached hash: {:?} signature: {:?}&quot;</span>,
							detach_hash,
							data.remote_signature
						);
					});
				},
			}

			<span class="self">Self</span>::deposit_event(Event::CollectionDetached {
				merkle_root: data.merkle_root,
				remote_signature: data.remote_signature,
				collection_type: data.collection.get_type(),
				collection: data.collection,
			});

			<span class="prelude-val">Ok</span>(())
		}
	}

	<span class="doccomment">/// Define some logic that should be executed regularly in some context, for e.g. `on_initialize`.
	</span><span class="attr">#[pallet::hooks]
	</span><span class="kw">impl</span>&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; <span class="kw">for </span>Pallet&lt;T&gt; {
		<span class="doccomment">/// During the block finalization phase, the **list** in **DetachRequests** is **stored in the Offchain DB** under the **key &quot;detach-requests&quot;**.
		/// After which, **DetachRequests** is **cleared**.
		///
		/// Note: `on_finalize` is executed at the end of block after all extrinsic are dispatched.
		</span><span class="kw">fn </span>on_finalize(_n: T::BlockNumber) {
			<span class="comment">// drain and process requests
			</span><span class="kw">let </span>requests = &lt;DetachRequests&lt;T&gt;&gt;::take();
			<span class="kw">if </span>!requests.is_empty() {
				<span class="macro">log::debug!</span>(<span class="string">&quot;Got {} detach requests&quot;</span>, requests.len());
				<span class="comment">// Write a key value pair to the Offchain DB database in a buffered fashion.
				// Source: https://paritytech.github.io/substrate/master/sp_io/offchain_index/fn.set.html#
				</span>offchain_index::set(<span class="string">b&quot;detach-requests&quot;</span>, <span class="kw-2">&amp;</span>requests.encode());
			}
		}

		<span class="doccomment">/// Implementing this function on a module allows you to perform long-running tasks
		/// that make (by default) validators generate transactions that feed results
		/// of those long-running computations back on chain.
		///
		/// NOTE: This function runs off-chain, so it can access the block state,
		/// but cannot preform any alterations. More specifically alterations are
		/// not forbidden, but they are not persisted in any way after the worker
		/// has finished.
		///
		/// This function is being called after every block import (when fully synced).
		///
		/// Implement this and use any of the `Offchain` `sp_io` set of APIs
		/// to perform off-chain computations, calls and submit transactions
		/// with results to trigger any on-chain changes.
		/// Any state alterations are lost and are not persisted.
		</span><span class="kw">fn </span>offchain_worker(_n: T::BlockNumber) {
			&lt;Pallet&lt;T&gt;&gt;::process_detach_requests();
		}
	}

	<span class="doccomment">/// By default, all unsigned transactions are rejected in Substrate.
	/// To enable Substrate to accept certain unsigned transactions, you must implement the ValidateUnsigned trait for the pallet.
	</span><span class="attr">#[pallet::validate_unsigned]
	</span><span class="kw">impl</span>&lt;T: Config&gt; ValidateUnsigned <span class="kw">for </span>Pallet&lt;T&gt; {
		<span class="kw">type </span>Call = Call&lt;T&gt;;

		<span class="doccomment">/// Whitelist and mark as valid the call `Call::internal_finalize_detach` only if:
		/// 1. The signer that signed the signed payload of the call is in `FragKeys`
		/// 2. The signature of the call can be verified against the signed payload of the call
		///
		/// Important Developer Note: Currently in this function, we are &quot;force type casting&quot; the signer that signed the payload of `Call:internal_finalize_detach`
		/// from `T::Public` to a `MultiSigner`.
		/// This is not ideal since we should not be making any assumptions about `T::Public`.
		///
		/// Footnote:
		///
		/// Validate unsigned call to this module.
		///
		/// By default unsigned transactions are disallowed, but implementing the validator
		/// here we make sure that some particular calls (the ones produced by offchain worker)
		/// are being whitelisted and marked as valid.
		</span><span class="kw">fn </span>validate_unsigned(source: TransactionSource, call: <span class="kw-2">&amp;</span><span class="self">Self</span>::Call) -&gt; TransactionValidity {
			<span class="comment">// Firstly let&#39;s check that we call the right function.
			</span><span class="kw">if let </span>Call::internal_finalize_detach { <span class="kw-2">ref </span>data, <span class="kw-2">ref </span>signature } = call {
				<span class="comment">// ensure it&#39;s a local transaction sent by an offchain worker
				</span><span class="kw">match </span>source {
					TransactionSource::InBlock | TransactionSource::Local =&gt; {},
					<span class="kw">_ </span>=&gt; {
						<span class="macro">log::debug!</span>(<span class="string">&quot;Not a local transaction&quot;</span>);
						<span class="kw">return </span>InvalidTransaction::Call.into()
					},
				}

				<span class="comment">// I&#39;m sure there is a way to do this without serialization but I can&#39;t spend so
				// much time fighting with rust
				</span><span class="kw">let </span>signer = data.public.encode(); <span class="comment">// Note: `signer` is public key of the signer that signed the signed payload `data` and thus produced the signature `signature`
								   // convert from `T::Public` to `ed25519::Public`
				</span><span class="kw">let </span>signer: ed25519::Public = {
					<span class="kw">if let </span><span class="prelude-val">Ok</span>(MultiSigner::Ed25519(signer)) =
						&lt;MultiSigner&gt;::decode(<span class="kw-2">&amp;mut &amp;</span>signer[..])
					{
						signer
					} <span class="kw">else </span>{
						<span class="kw">return </span>InvalidTransaction::BadSigner.into()
					}
				};
				<span class="macro">log::debug!</span>(<span class="string">&quot;Public key: {:?}&quot;</span>, signer);

				<span class="macro">log::debug!</span>(<span class="string">&quot;Valid keys: {:?}&quot;</span>, &lt;DetachKeys&lt;T&gt;&gt;::get());
				<span class="comment">// signer must be in `DetachKeys`
				</span><span class="kw">if </span>!&lt;DetachKeys&lt;T&gt;&gt;::get().contains(<span class="kw-2">&amp;</span>signer) {
					<span class="kw">return </span>InvalidTransaction::BadSigner.into()
				}

				<span class="comment">// most expensive bit last

				// Verify signature `signature` against SignedPayload object `data`. Returns a bool indicating whether the signature is valid or not.
				//
				// Source: https://paritytech.github.io/substrate/master/frame_system/offchain/trait.SignedPayload.html#method.verify
				</span><span class="kw">if </span>!SignedPayload::&lt;T&gt;::verify::&lt;T::AuthorityId&gt;(data, signature.clone()) {
					<span class="kw">return </span>InvalidTransaction::BadProof.into()
				}
				<span class="macro">log::debug!</span>(<span class="string">&quot;Sending detach finalization extrinsic&quot;</span>);
				<span class="comment">// The tag prefix prevents other nodes to do the same transaction that have the same tag prefixes
				</span>ValidTransaction::with_tag_prefix(<span class="string">&quot;Detach&quot;</span>)
					<span class="comment">// This transaction does not require anything else to go before into the pool.
					// In theory we could require `previous_unsigned_at` transaction to go first,
					// but it&#39;s not necessary in our case.
					//.and_requires()
					// We set the `provides` tag to be the same as `next_unsigned_at`. This makes
					// sure only one transaction produced after `next_unsigned_at` will ever
					// get to the transaction pool and will end up in the block.
					// We can still have multiple transactions compete for the same &quot;spot&quot;,
					// and the one with higher priority will replace other one in the pool.
					</span>.and_provides((
						data.collection.get_type(),
						data.merkle_root,
						data.target_chain,
						data.target_account.clone(),
						data.nonce,
					))
					<span class="comment">// It&#39;s fine to propagate that transaction to other peers, which means it can be
					// created even by nodes that don&#39;t produce blocks.
					// Note that sometimes it&#39;s better to keep it for yourself (if you are the block
					// producer), since for instance in some schemes others may copy your solution and
					// claim a reward.
					</span>.propagate(<span class="bool-val">false</span>)
					.build()
			} <span class="kw">else </span>{
				InvalidTransaction::Call.into()
			}
		}
	}

	<span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
		<span class="doccomment">/// Set the initial set of ECDSA public keys in `EthereumAuthorities`
		</span><span class="kw">fn </span>initialize_eth_authorities(authorities: <span class="kw-2">&amp;</span>[ecdsa::Public]) {
			<span class="kw">if </span>!authorities.is_empty() {
				<span class="macro">assert!</span>(
					&lt;EthereumAuthorities&lt;T&gt;&gt;::get().is_empty(),
					<span class="string">&quot;EthereumAuthorities are already initialized!&quot;
				</span>);
				<span class="kw">for </span>authority <span class="kw">in </span>authorities {
					&lt;EthereumAuthorities&lt;T&gt;&gt;::mutate(|authorities| {
						authorities.insert(<span class="kw-2">*</span>authority);
					});
				}
			}
		}

		<span class="doccomment">/// Set the initial set of Ed25519 public keys in `DetachKeys`
		</span><span class="kw">fn </span>initialize_keys(keys: <span class="kw-2">&amp;</span>[ed25519::Public]) {
			<span class="kw">if </span>!keys.is_empty() {
				<span class="macro">assert!</span>(&lt;DetachKeys&lt;T&gt;&gt;::get().is_empty(), <span class="string">&quot;DetachKeys are already initialized!&quot;</span>);
				<span class="kw">for </span>key <span class="kw">in </span>keys {
					&lt;DetachKeys&lt;T&gt;&gt;::mutate(|keys| {
						keys.insert(<span class="kw-2">*</span>key);
					});
				}
			}
		}

		<span class="doccomment">/// Adds newly-found Ed25519 keys to the persistent local storage under the key `b&quot;detach-ecdsa-keys&quot;`.
		/// Furthermore, for each newly-found Ed25519 key - an ECDSA key is deterministically computed (using the Ed25519 key) which is then added to the keystore under the key id `KEY_TYPE`.
		</span><span class="kw">fn </span>add_newly_found_ed25519_and_ecdsa_keys() {
			<span class="comment">// Get a storage value reference (i.e `StorageValueRef`) of the key `b&quot;detach-ecdsa-keys&quot;` in the persistent local storage
			</span><span class="kw">let </span>storage_ref = StorageValueRef::persistent(<span class="string">b&quot;detach-ecdsa-keys&quot;</span>);
			<span class="kw">let </span><span class="kw-2">mut </span>persisted_ed25119_keys =
				<span class="self">Self</span>::get_ed25519_keys_from_storage_value_reference(<span class="kw-2">&amp;</span>storage_ref);

			<span class="comment">// doing it like this cos mutate was insane...
			</span><span class="kw">let </span><span class="kw-2">mut </span>edited = <span class="bool-val">false</span>;

			<span class="comment">// Add Ed25519 keys that are not currently in the persistent local storage (under the key `b&quot;detach-ecdsa-keys&quot;`) to the persistent local storage.
			// Furthermore - for each Ed25519 key that&#39;s currently not in the persistent local storage, deterministically compute an ECDSA key and add it to the keystore under key id `KEY_TYPE`.
			//
			// Footnote:
			// `sp_io::crypto::ed25519_public_keys` returns all ed25519 public keys for the given key id (in our case it&#39;s `KEY_TYPE`) from the keystore
			// Source: https://docs.rs/sp-io/latest/sp_io/crypto/fn.ed25519_public_keys.html
			</span><span class="kw">for </span>ed25519_key <span class="kw">in </span><span class="kw-2">&amp;</span>Crypto::ed25519_public_keys(KEY_TYPE) {
				<span class="comment">// Ed25519 key `ed25519_key` is not in `persisted_ed25119_keys`
				</span><span class="kw">if </span>!persisted_ed25119_keys.contains(ed25519_key) {
					<span class="kw">let </span>ecdsa_seed_hex =
						<span class="self">Self</span>::generate_ecdsa_seed_from_ed25519_key(<span class="kw-2">&amp;</span>ed25519_key).unwrap();
					<span class="macro">log::debug!</span>(<span class="string">&quot;Adding new key from seed: {:?}&quot;</span>, ecdsa_seed_hex);
					<span class="comment">// `sp_io::crypto::ecdsa_generate` generates an ecdsa key for the given key type using an optional seed (in our case it&#39;s `Some(key_hex)`)
					// and store it in the keystore. The seed needs to be a valid utf8.
					// Source: https://paritytech.github.io/substrate/master/sp_io/crypto/fn.ecdsa_generate.html#
					//
					// Very Important Note: Since this function &quot;store[s] it [i.e the eccdsa key] in the keystore&quot;,
					// the ecdsa key will be retrievable when doing `sp_io::crypto::ecdsa_public_keys(KEY_TYPE)`
					</span><span class="kw">let </span>_public = Crypto::ecdsa_generate(KEY_TYPE, <span class="prelude-val">Some</span>(ecdsa_seed_hex));
					persisted_ed25119_keys.insert(<span class="kw-2">*</span>ed25519_key);
					edited = <span class="bool-val">true</span>;
				}
			}
			<span class="kw">if </span>edited {
				<span class="comment">// Update the storage value that is referred by `storage_ref` to `persisted_ed25119_keys`
				</span>storage_ref.set(<span class="kw-2">&amp;</span>persisted_ed25119_keys);
			}
		}

		<span class="kw">fn </span>get_merkle_root(detach_collection: <span class="kw-2">&amp;</span>DetachCollection) -&gt; Hash256 {
			<span class="kw">let </span><span class="kw-2">mut </span>detach_hashes = detach_collection.get_abi_encoded_hashes();
			detach_hashes.sort_by(|a, b| Keccak256::hash(a).cmp(<span class="kw-2">&amp;</span>Keccak256::hash(b)));
			merkle_root::&lt;Keccak256, <span class="kw">_</span>&gt;(detach_hashes).into()
		}

		<span class="doccomment">/// Returns a Tuple of the following things:
		/// 1. A **Signature** obtained by **signing the detach request `request` using a Fragnova-authorized account**.
		///
		/// Note: Since it was signed by a Fragnova-authorized account, this signature can be presented to the External Blockchain `requests.target_chain`
		/// to attach the &quot;detached thing&quot; (e.g a detached Proto-Fragment or a detached Fragment Instance) to the External Blockchain.
		///
		/// 2. The Detach-Nonce of the detach request&#39;s target account. (See `DetachNonces` for more information).
		///
		/// 3. **Merkle Root** of a **Binary Merkle Tree created using `request.hashes`**
		</span><span class="kw">fn </span>get_detach_signature_and_detach_nonce_and_merkle_root(
			request: <span class="kw-2">&amp;</span>DetachRequest,
		) -&gt; <span class="prelude-ty">Result</span>&lt;(Vec&lt;u8&gt;, u64, Hash256), Error&lt;T&gt;&gt; {
			<span class="kw">match </span>request.target_chain {
				SupportedChains::EthereumMainnet |
				SupportedChains::EthereumRinkeby |
				SupportedChains::EthereumGoerli =&gt; {
					<span class="self">Self</span>::add_newly_found_ed25519_and_ecdsa_keys();

					<span class="comment">// `sp_io::crypto::ecdsa_public_keys` returns all ecdsa public keys for the given key id from the keystore. (in our case the key id is `KEY_TYPE`).
					// Source: https://docs.rs/sp-io/latest/sp_io/crypto/fn.ecdsa_public_keys.html
					</span><span class="kw">let </span>ecdsa_keys = Crypto::ecdsa_public_keys(KEY_TYPE);
					<span class="macro">log::debug!</span>(<span class="string">&quot;ecdsa local keys {:x?}&quot;</span>, ecdsa_keys);

					<span class="comment">// make sure the local key is in the global authorities set!
					</span><span class="kw">let </span>ethereum_authority = ecdsa_keys
						.iter()
						.find(|k| &lt;EthereumAuthorities&lt;T&gt;&gt;::get().contains(k))
						.ok_or(Error::&lt;T&gt;::NoValidator)<span class="question-mark">?</span>;

					<span class="kw">let </span>merkle_root = <span class="self">Self</span>::get_merkle_root(<span class="kw-2">&amp;</span>request.collection);
					<span class="comment">// Note: In Fragnova&#39;s Smart Contract `CollectionFactory.sol`, the mapping state variable `nonces`&#39;s (`mapping(address =&gt; uint64) nonces`) nonce type is also `uint64`
					</span><span class="kw">let </span>nonce =
						&lt;DetachNonces&lt;T&gt;&gt;::get(<span class="kw-2">&amp;</span>request.target_account, request.target_chain)
							.unwrap_or_default()
							.checked_add(<span class="number">1</span>)
							.unwrap();
					<span class="comment">// Note: In Solidity, `block.chainid` is of type `uint256`
					</span><span class="kw">let </span><span class="kw-2">mut </span>chain_id_be: [u8; <span class="number">32</span>] = [<span class="number">0u8</span>; <span class="number">32</span>]; <span class="comment">// &quot;be&quot; stands for big-endian
					</span><span class="kw">match </span>request.target_chain {
						SupportedChains::EthereumMainnet =&gt; U256::from(<span class="number">1</span>),
						SupportedChains::EthereumRinkeby =&gt; U256::from(<span class="number">4</span>),
						SupportedChains::EthereumGoerli =&gt; U256::from(<span class="number">5</span>),
					}
					.to_big_endian(<span class="kw-2">&amp;mut </span>chain_id_be);

					<span class="kw">let </span>payload = [
						<span class="comment">// In Fragnova&#39;s Smart Contract `CollectionFactory.sol`, we convert the enum `CollectionType` to `uint8` when verifying the signature.
						// Therefore, when constructing the signature - we are also converting it to `u8`.
						</span><span class="kw-2">&amp;</span>(request.collection.get_type() <span class="kw">as </span>u8).to_be_bytes()[..],
						<span class="kw-2">&amp;</span>merkle_root[..],
						<span class="kw-2">&amp;</span>chain_id_be,
						<span class="kw-2">&amp;</span>TryInto::&lt;[u8; <span class="number">20</span>]&gt;::try_into(request.target_account.clone())
							.map_err(|<span class="kw">_</span>| Error::&lt;T&gt;::TargetAccountLengthIsIncorrect)<span class="question-mark">?</span>,
						<span class="kw-2">&amp;</span>nonce.to_be_bytes(), <span class="comment">// &quot;be&quot; stands for big-endian
					</span>]
					.concat();
					<span class="macro">log::debug!</span>(<span class="string">&quot;payload: {:x?}, len: {}&quot;</span>, payload, payload.len());

					<span class="comment">// Get the Ethereum specific signature of the payload
					</span><span class="kw">let </span>signature = <span class="self">Self</span>::eth_sign_payload(<span class="kw-2">&amp;</span>ethereum_authority, <span class="kw-2">&amp;</span>payload)
						.ok_or(Error::&lt;T&gt;::SigningFailed)<span class="question-mark">?</span>;

					<span class="prelude-val">Ok</span>((signature.<span class="number">0</span>.to_vec(), nonce, merkle_root))
				},
			}
		}

		<span class="doccomment">/// Signs the list of detach requests using a Fragnova-authorized account.
		/// Then, for each of the signed detach requests - send an unsigned transaction on-chain
		/// that will cause an event to be emitted which will contain the detach request&#39;s signature.
		/// This signature can be then used in the target chain to attach the &quot;detachable thing&quot; (see enum `DetachHash` to see what type of things can be detached) to the target chain.
		///
		/// The format of each detach request (which is then signed by a Fragnova-authorized account) is as follows:
		/// keccak_256(&lt;Proto-Fragment Hash&gt; ‖ &lt;Target Chain ID&gt; ‖ &lt;Public Account Address in Target Chain to assign ownership of Proto-Fragment to&gt; ‖ &lt;Detach Nonce of Public Account Address in Target Chain (see `DetachNonces`)&gt;)
		///
		/// Note: On the Target Chain, the &quot;attach nonce&quot; needs to be exactly the same as the detach nonce here.
		</span><span class="kw">pub fn </span>process_detach_requests() {
			<span class="kw">const </span>FAILED: () = ();

			<span class="comment">/*
			Use `StorageValueRef::persistent(b&quot;detach-requests&quot;)`
			to get a reference to the storage value that&#39;s under the key `b&quot;detach-requests&quot;` in the persistent local storage.
			and use `StorageValueRef::mutate()`
			to set that storage value to a new value.

			In our case, the storage value is the vector of detach requests.
			And in our case, we set the storage value to an empty vector after processing the vector of detach requests

			Reference: https://paritytech.github.io/substrate/master/sp_runtime/offchain/storage/struct.StorageValueRef.html#method.mutate)
			 */
			</span><span class="kw">let _ </span>= StorageValueRef::persistent(<span class="string">b&quot;detach-requests&quot;</span>).mutate(
				|requests: <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;DetachRequest&gt;&gt;, <span class="kw">_</span>&gt;| {
					<span class="kw">let </span>requests = requests.map_err(|<span class="kw">_</span>| FAILED)<span class="question-mark">?</span>.ok_or(FAILED)<span class="question-mark">?</span>;

					<span class="macro">log::debug!</span>(<span class="string">&quot;Got {} detach requests&quot;</span>, requests.len());
					<span class="kw">for </span>request <span class="kw">in </span>requests {
						<span class="comment">// Iterate through the list of detach requests

						</span><span class="kw">let </span>tuple_signature_nonce_merkle_root =
							<span class="self">Self</span>::get_detach_signature_and_detach_nonce_and_merkle_root(<span class="kw-2">&amp;</span>request);

						<span class="kw">match </span>tuple_signature_nonce_merkle_root {
							<span class="prelude-val">Err</span>(e) =&gt; {
								<span class="macro">log::debug!</span>(<span class="string">&quot;Failed to detach with error {:?}&quot;</span>, e)
							},
							<span class="comment">// begin process to send unsigned transaction from here
							</span><span class="prelude-val">Ok</span>((signature, nonce, merkle_root)) =&gt; {
								<span class="macro">log::debug!</span>(
										<span class="string">&quot;Executing unsigned transaction for detach; signature: {:x?}, nonce: {}&quot;</span>,
										signature,
										nonce
									);

								<span class="comment">/*
								Sign using any account

								Footnote:
								Since this pallet only has one key type in the keystore (i.e `KeyTypeId(*b&quot;deta&quot;)`),
								we can just use `any_account() to retrieve a key (that is of the aforementioned key type).
								Reference: https://paritytech.github.io/substrate/master/frame_system/offchain/struct.Signer.html
								*/
								</span><span class="kw">if let </span><span class="prelude-val">Err</span>(e) = Signer::&lt;T, T::AuthorityId&gt;::any_account()
									<span class="comment">/*
									Send an unsigned transaction with a signed payload on-chain.
									This method takes `f` and `f2` where:
									- `f` is called for every account and is expected to return a `SignedPayload` object.
									- `f2` is then called with the `SignedPayload` returned by `f` and the signature and is
									expected to return a `Call` object to be embedded into transaction.
									Source: https://paritytech.github.io/substrate/master/frame_system/offchain/trait.SendUnsignedTransaction.html#tymethod.send_unsigned_transaction
									*/
									</span>.send_unsigned_transaction(
										|account| DetachInternalData {
											<span class="comment">// Public key that is expected to have a matching key in the keystore, which should be used to sign the payload
											// Note: See the implementation of `SignedPayload` for `DetachInternalData` to understand more
											</span>public: account.public.clone(),
											collection: request.collection.clone(),
											merkle_root,
											target_chain: request.target_chain,
											target_account: request.target_account.clone(),
											remote_signature: signature.clone(),
											nonce,
										},
										<span class="comment">// Note: `Call` is an enum that gets generated by the macro `#[pallet::Call]`
										// You can view it in Fragnova&#39;s Rustdoc: https://fragcolor-xyz.github.io/fragnova/doc/pallet_detach/pallet/enum.Call.html#
										</span>|payload, signature| Call::internal_finalize_detach {
											data: payload,
											signature,
										},
									)
									.ok_or(<span class="string">&quot;No local accounts accounts available.&quot;</span>)
								{
									<span class="macro">log::error!</span>(<span class="string">&quot;Failed to send unsigned detach transaction with error: {:?}&quot;</span>, e);
								}
							},
						}
					}

					<span class="comment">// We set the storage value to an empty vector after processing the vector of detach requests
					</span><span class="prelude-val">Ok</span>::&lt;Vec&lt;DetachRequest&gt;, ()&gt;(<span class="macro">vec!</span>[])
				},
			);
		}

		<span class="doccomment">/// Deterministically compute an ECDSA Seed using the Ed25519 public key `ed25519_key`.
		/// The ECDSA Seed is then returned as a UTF-8 encoded hexadecimal.
		</span><span class="kw">fn </span>generate_ecdsa_seed_from_ed25519_key(ed25519_key: <span class="kw-2">&amp;</span>Public) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, ()&gt; {
			<span class="kw">const </span>FAILED: () = ();
			<span class="kw">let </span><span class="kw-2">mut </span>msg = <span class="string">b&quot;detach-ecdsa-keys&quot;</span>.to_vec();
			msg.append(<span class="kw-2">&amp;mut </span>ed25519_key.to_vec());
			<span class="comment">// Sign the fixed message `b&quot;detach-ecdsa-keys&quot; ‖ ed25519_key` using Ed25519 key `ed25519_key`
			</span><span class="kw">let </span>signature = Crypto::ed25519_sign(KEY_TYPE, ed25519_key, <span class="kw-2">&amp;</span>msg).unwrap();
			<span class="kw">let </span>ecdsa_seed = keccak_256(<span class="kw-2">&amp;</span>signature.<span class="number">0</span>[..]);

			<span class="kw">let </span>ecdsa_seed_hex = [
				<span class="kw-2">&amp;</span><span class="string">b&quot;0x&quot;</span>[..],
				<span class="kw-2">&amp;</span>TryInto::&lt;[u8; <span class="number">64</span>]&gt;::try_into(hex::encode(ecdsa_seed).into_bytes())
					.map_err(|<span class="kw">_</span>| FAILED)<span class="question-mark">?</span>, <span class="comment">// actually there&#39;s no need to throw any error I think...
			</span>]
			.concat();

			<span class="prelude-val">Ok</span>(ecdsa_seed_hex)
		}

		<span class="comment">// Sign the payload `payload` using the ecdsa `key` and return the signature.
		// Note: The signature is an Ethereum specific signature
		</span><span class="kw">fn </span>eth_sign_payload(key: <span class="kw-2">&amp;</span>ecdsa::Public, payload: <span class="kw-2">&amp;</span>Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;ecdsa::Signature&gt; {
			<span class="kw">let </span>payload_hash = keccak_256(<span class="kw-2">&amp;</span>payload);
			<span class="macro">log::debug!</span>(<span class="string">&quot;payload hash: {:x?}, len: {}&quot;</span>, payload_hash, payload_hash.len());
			<span class="kw">let </span>msg = [<span class="string">b&quot;\x19Ethereum Signed Message:\n32&quot;</span>, <span class="kw-2">&amp;</span>payload_hash[..]].concat();
			<span class="kw">let </span>msg = keccak_256(<span class="kw-2">&amp;</span>msg);

			<span class="comment">// Sign the given a pre-hashed msg `msg` with the ecdsa key that corresponds to the given public key `key` and key type `KEY_TYPE` in the keystore. Returns the signature.
			// Source: https://paritytech.github.io/substrate/master/sp_io/crypto/fn.ecdsa_sign_prehashed.html#
			</span><span class="kw">let </span>signature =
				Crypto::ecdsa_sign_prehashed(KEY_TYPE, key, <span class="kw-2">&amp;</span>msg).map(|<span class="kw-2">mut </span>signature| {
					signature.<span class="number">0</span>[<span class="number">64</span>] += <span class="number">27u8</span>; <span class="comment">// fix signature ending for ethereum
					</span>signature
				});

			signature
		}

		<span class="doccomment">/// Return the Set of Ed25519 public keys that are stored in the StorageValueRef `storage_ref`, if any. Otherwise, return an empty set.
		</span><span class="kw">fn </span>get_ed25519_keys_from_storage_value_reference(
			storage_ref: <span class="kw-2">&amp;</span>StorageValueRef,
		) -&gt; BTreeSet&lt;ed25519::Public&gt; {
			<span class="comment">// If `stored_keys` doesn&#39;t exist, set it to `BTreeSet&lt;ed25519::Public&gt;`
			</span><span class="kw">let </span>stored_keys = storage_ref.get::&lt;BTreeSet&lt;ed25519::Public&gt;&gt;().unwrap_or_default();
			<span class="comment">// If `keys` is None, set it to `BTreeSet&lt;ed25519::Public&gt;`
			</span><span class="kw">let </span>keys = <span class="kw">if let </span><span class="prelude-val">Some</span>(keys) = stored_keys { keys } <span class="kw">else </span>{ BTreeSet::new() };
			keys
		}
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pallet_detach" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>